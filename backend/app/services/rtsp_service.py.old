# backend/app/services/rtsp_service.py
"""
RTSP Service - RTSP/OpenCV Capture Actions

🎯 SERVICE SCOPE: Anything that involves CAPTURING IMAGES via OpenCV/RTSP
- Frame capture operations (capture_frame, capture_preview)
- RTSP connectivity testing for capture readiness
- Image processing pipeline (crop, rotate, save)
- Database record creation for captured images
- Transaction safety for capture operations
- Corruption detection coordination
- Thumbnail job queuing

📝 KEY DISTINCTION FROM CameraService:
- RTSPService = "DO something with RTSP/camera" (actions/verbs)
- CameraService = "MANAGE camera entity" (CRUD/status/metadata)

⚠️  NOT responsible for:
- Camera entity CRUD operations
- Camera health/status management
- Camera scheduling metadata
- Camera business logic orchestration

Architecture: Single source of truth for all RTSP capture operations
"""

import time
import asyncio
from pathlib import Path
from typing import Optional, Dict, Any
from datetime import datetime, timezone
from loguru import logger

from ..database.core import SyncDatabase
from ..database.image_operations import SyncImageOperations
from ..database.camera_operations import SyncCameraOperations
from ..database.timelapse_operations import SyncTimelapseOperations
from ..database.settings_operations import SyncSettingsOperations
from ..database.weather_operations import SyncWeatherOperations
from ..database.thumbnail_job_operations import SyncThumbnailJobOperations

from ..models.shared_models import (
    RTSPCaptureResult,
    CameraConnectivityTestResult,
    ThumbnailGenerationJobCreate,
)
from ..models.camera_model import (
    CropRotationSettings,
    SourceResolution,
)
from ..models.image_model import ImageCreate
from ..models.camera_model import Camera

from ..utils import file_helpers, time_utils
from .capture_pipeline import rtsp_utils
from ..exceptions import RTSPConnectionError, RTSPCaptureError

from ..constants import (
    DEFAULT_MAX_RETRIES,
    CAMERA_CONNECTION_SUCCESS,
    
    CAMERA_CAPTURE_SUCCESS,
    CAMERA_CAPTURE_FAILED,
    CAMERA_NOT_FOUND,
    DEFAULT_IMAGE_EXTENSION,
    DEFAULT_RTSP_QUALITY,
    DEFAULT_RTSP_TIMEOUT_SECONDS,
    DEFAULT_CORRUPTION_SCORE,
    DEFAULT_IS_FLAGGED,
    THUMBNAIL_JOB_PRIORITY_MEDIUM,
    THUMBNAIL_JOB_STATUS_PENDING,
    THUMBNAIL_JOB_TYPE_SINGLE,
    SETTING_KEY_THUMBNAIL_GENERATION_ENABLED,
)


class RTSPService:
    """
    Unified RTSP service consolidating all RTSP operations.

    Single source of truth for:
    - RTSP connectivity testing
    - Frame capture and processing
    - Database record creation
    - Transaction safety
    - Integration with corruption detection
    """

    def __init__(
        self,
        db: SyncDatabase,
        corruption_service: Optional[Any] = None,
        transaction_manager: Optional[Any] = None,
        job_queue_service: Optional[Any] = None,
    ):
        """Initialize unified RTSP service with dependency injection."""
        self.db = db
        self.image_ops = SyncImageOperations(db)
        self.camera_ops = SyncCameraOperations(db)
        self.timelapse_ops = SyncTimelapseOperations(db)
        self.settings_ops = SyncSettingsOperations(db)
        self.weather_ops = SyncWeatherOperations(db)
        self.thumbnail_job_ops = SyncThumbnailJobOperations(db)

        # Optional services for advanced features
        self.corruption_service = corruption_service
        self.transaction_manager = transaction_manager
        self.job_queue_service = job_queue_service

    def test_connection(
        self, camera_id: int, rtsp_url: str
    ) -> CameraConnectivityTestResult:
        """
        Test RTSP connectivity for a camera.

        Consolidated from both ImageCaptureService and RTSPCaptureService.

        Args:
            camera_id: ID of camera to test
            rtsp_url: RTSP URL to test

        Returns:
            CameraConnectivityTestResult with test results
        """
        try:
            start_time = time.time()

            settings = self._get_capture_settings()
            success, message = rtsp_utils.test_rtsp_connection(
                rtsp_url, timeout_seconds=settings["timeout"]
            )

            response_time_ms = (time.time() - start_time) * 1000

            return CameraConnectivityTestResult(
                success=success,
                camera_id=camera_id,
                rtsp_url=rtsp_url,
                response_time_ms=response_time_ms,
                connection_status="online" if success else "offline",
                error=None if success else message,
                test_timestamp=time_utils.get_timezone_aware_timestamp_sync(
                    self.settings_ops
                ),
            )

        except Exception as e:
            logger.error(f"Error testing RTSP connection for camera {camera_id}: {e}")
            return CameraConnectivityTestResult(
                success=False,
                camera_id=camera_id,
                rtsp_url=rtsp_url,
                response_time_ms=None,
                connection_status="error",
                error=str(e),
                test_timestamp=time_utils.get_timezone_aware_timestamp_sync(
                    self.settings_ops
                ),
            )

    def capture_frame(self, camera_id: int, timelapse_id: int) -> RTSPCaptureResult:
        """
        Capture frame for active timelapse with full workflow.

        Main entry point for all frame capture operations.
        Includes transaction safety if transaction_manager is available.

        Args:
            camera_id: ID of camera
            timelapse_id: ID of active timelapse

        Returns:
            RTSPCaptureResult with capture results
        """
        # Get camera details
        camera = self._get_camera_with_validation(camera_id)
        if not camera:
            return RTSPCaptureResult(
                success=False, error=f"Camera {camera_id} not found"
            )

        # Use transaction safety if available
        if self.transaction_manager:
            return self._capture_frame_with_transaction(camera, timelapse_id)
        else:
            return self._capture_frame_standard(camera, timelapse_id)

    def capture_preview(self, camera_id: int) -> RTSPCaptureResult:
        """
        Capture preview image without saving to timelapse.

        For manual testing and preview functionality.

        Args:
            camera_id: ID of camera

        Returns:
            RTSPCaptureResult with capture results
        """
        camera = self._get_camera_with_validation(camera_id)
        if not camera:
            return RTSPCaptureResult(
                success=False, error=f"Camera {camera_id} not found"
            )

        try:
            # Test connectivity first
            connectivity_result = self.test_connection(camera_id, camera.rtsp_url)
            if not connectivity_result.success:
                return RTSPCaptureResult(
                    success=False,
                    error=f"Connectivity test failed: {connectivity_result.error}",
                )

            # Capture frame without saving to database (reuse settings from connectivity test)
            settings = self._get_capture_settings()
            frame = rtsp_utils.capture_with_retry(
                rtsp_url=camera.rtsp_url,
                max_retries=DEFAULT_MAX_RETRIES,
                timeout_seconds=settings["timeout"],
            )

            if frame is None:
                return RTSPCaptureResult(
                    success=False, error="Failed to capture frame from RTSP stream"
                )

            return RTSPCaptureResult(
                success=True,
                message="Preview frame captured successfully",
                metadata={"preview_mode": True},
            )

        except Exception as e:
            logger.error(f"Error capturing preview for camera {camera_id}: {e}")
            return RTSPCaptureResult(success=False, error=str(e))

    def _capture_frame_with_transaction(
        self, camera: Camera, timelapse_id: int
    ) -> RTSPCaptureResult:
        """Capture frame with transaction safety."""
        if not self.transaction_manager:
            # Fallback to standard capture if transaction manager not available
            return self._capture_frame_standard(camera, timelapse_id)

        try:
            # Start transaction
            with self.transaction_manager.capture_transaction(camera.id) as tx:
                result = self._perform_capture_workflow(camera, timelapse_id)

                if result.success:
                    # Set transaction data for automatic commit
                    tx.file_path = result.image_path
                    tx.image_id = result.image_id

                return result

        except Exception as e:
            logger.error(f"Transaction capture failed for camera {camera.id}: {e}")
            return RTSPCaptureResult(success=False, error=str(e))

    def _capture_frame_standard(
        self, camera: Camera, timelapse_id: int
    ) -> RTSPCaptureResult:
        """Capture frame with manual cleanup on failure."""
        try:
            result = self._perform_capture_workflow(camera, timelapse_id)

            if not result.success and result.image_path:
                # Manual cleanup on failure
                try:
                    Path(result.image_path).unlink(missing_ok=True)
                    logger.info(f"Cleaned up failed capture file: {result.image_path}")
                except Exception as cleanup_error:
                    logger.warning(f"Failed to cleanup file: {cleanup_error}")

            return result

        except Exception as e:
            logger.error(f"Standard capture failed for camera {camera.id}: {e}")
            return RTSPCaptureResult(success=False, error=str(e))

    def _perform_capture_workflow(
        self, camera: Camera, timelapse_id: int, skip_connectivity_test: bool = False
    ) -> RTSPCaptureResult:
        """Perform the complete capture workflow."""
        try:
            logger.info(
                f"Starting capture workflow for camera {camera.id}, timelapse {timelapse_id}"
            )

            # Test connectivity first (unless already tested)
            if not skip_connectivity_test:
                connectivity_result = self.test_connection(camera.id, camera.rtsp_url)
                if not connectivity_result.success:
                    return RTSPCaptureResult(
                        success=False,
                        error=f"Connectivity test failed: {connectivity_result.error}",
                    )

            # Get timelapse info for day number calculation
            timelapse = self.timelapse_ops.get_timelapse_by_id(timelapse_id)
            if not timelapse:
                return RTSPCaptureResult(
                    success=False, error=f"Timelapse {timelapse_id} not found"
                )

            # Calculate day number
            day_number = time_utils.calculate_day_number_for_timelapse(
                timelapse, self.settings_ops
            )

            # Generate file paths
            frames_dir = file_helpers.ensure_entity_directory(
                camera_id=camera.id, timelapse_id=timelapse_id, subdirectory="frames"
            )

            timestamp_str = time_utils.get_timezone_aware_timestamp_string_sync(self.db)
            filename = f"day{day_number:03d}_{timestamp_str}{DEFAULT_IMAGE_EXTENSION}"
            filepath = frames_dir / filename

            # Capture frame
            settings = self._get_capture_settings()
            frame = rtsp_utils.capture_with_retry(
                rtsp_url=camera.rtsp_url,
                max_retries=DEFAULT_MAX_RETRIES,
                timeout_seconds=settings["timeout"],
            )

            if frame is None:
                return RTSPCaptureResult(
                    success=False, error="Failed to capture frame from RTSP stream"
                )

            # Apply image processing
            processing_result = self._apply_image_processing(
                camera, frame, filepath, settings
            )
            if not processing_result["success"]:
                return RTSPCaptureResult(
                    success=False, error=processing_result["error"]
                )

            # Create database record
            image_record = self._create_image_record(
                camera.id,
                timelapse_id,
                filepath,
                day_number,
                processing_result["file_size"],
            )

            # Queue background jobs
            self._queue_background_jobs(image_record.id)

            # Coordinate corruption detection if enabled
            if (
                getattr(camera, "corruption_detection_enabled", False)
                and self.corruption_service
            ):
                self._coordinate_corruption_detection(camera.id, str(filepath))

            return RTSPCaptureResult(
                success=True,
                message=CAMERA_CAPTURE_SUCCESS,
                image_id=image_record.id,
                image_path=str(filepath),
                file_size=processing_result["file_size"],
                metadata={
                    "day_number": day_number,
                    "timelapse_id": timelapse_id,
                    "entity_based": True,
                },
            )

        except Exception as e:
            logger.error(f"Capture workflow failed for camera {camera.id}: {e}")
            return RTSPCaptureResult(success=False, error=str(e))

    def _apply_image_processing(
        self, camera: Camera, frame, filepath: Path, settings: Dict
    ) -> Dict[str, Any]:
        """Apply image processing pipeline (crop, rotation, etc.)."""
        try:
            # Get processing settings from camera crop_rotation_settings
            processing_settings = None
            if getattr(camera, "crop_rotation_enabled", False):
                crop_settings_data = getattr(camera, "crop_rotation_settings", {}) or {}
                if crop_settings_data:
                    processing_settings = crop_settings_data

            # Fallback to legacy rotation
            legacy_rotation = (
                getattr(camera, "rotation", 0) if processing_settings is None else 0
            )

            # Save frame with processing
            success, file_size = rtsp_utils.save_frame_to_file(
                frame=frame,
                filepath=filepath,
                quality=settings["quality"],
                rotation=legacy_rotation,
                processing_settings=processing_settings,
            )

            if not success:
                return {"success": False, "error": "Failed to save processed frame"}

            return {"success": True, "file_size": file_size}

        except Exception as e:
            return {"success": False, "error": f"Image processing failed: {e}"}

    def _create_image_record(
        self,
        camera_id: int,
        timelapse_id: int,
        filepath: Path,
        day_number: int,
        file_size: int,
    ):
        """Create image database record with weather data."""
        # Get current weather data
        weather_data = self._get_current_weather_data()

        # Create relative path
        relative_path = file_helpers.get_relative_path(filepath)

        # Create image record
        image_create = ImageCreate(
            camera_id=camera_id,
            timelapse_id=timelapse_id,
            file_path=str(relative_path),
            day_number=day_number,
            file_size=file_size,
            corruption_score=DEFAULT_CORRUPTION_SCORE,
            is_flagged=DEFAULT_IS_FLAGGED,
            corruption_details=None,
            captured_at=datetime.now(timezone.utc),
            corruption_detected=False,
            thumbnail_path=None,
            # Weather data
            weather_temperature=weather_data.get("weather_temperature"),
            weather_conditions=weather_data.get("weather_conditions"),
            weather_icon=weather_data.get("weather_icon"),
            weather_fetched_at=weather_data.get("weather_fetched_at"),
            # Overlay fields
            overlay_path=None,
            overlay_updated_at=None,
        )

        return self.image_ops.record_captured_image(image_create.model_dump())

    def _queue_background_jobs(self, image_id: int) -> None:
        """Queue thumbnail generation and other background jobs."""
        try:
            # Check if thumbnail generation is enabled
            thumbnail_enabled = self.settings_ops.get_setting(
                SETTING_KEY_THUMBNAIL_GENERATION_ENABLED, "true"
            )

            if str(thumbnail_enabled).lower() != "true":
                logger.debug(
                    f"Thumbnail generation disabled, skipping job for image {image_id}"
                )
                return

            if self.job_queue_service:
                # Use centralized JobQueueService
                job_id = self.job_queue_service.create_thumbnail_job(
                    image_id=image_id,
                    priority=THUMBNAIL_JOB_PRIORITY_MEDIUM,
                    job_type=THUMBNAIL_JOB_TYPE_SINGLE,
                    broadcast_sse=True,  # Enable SSE broadcasting
                )

                if job_id:
                    logger.debug(
                        f"✅ Queued thumbnail job {job_id} for image {image_id} via JobQueueService"
                    )
                else:
                    logger.warning(
                        f"❌ Failed to queue thumbnail job for image {image_id} via JobQueueService"
                    )
            else:
                # Fallback to direct database operations
                job_data = ThumbnailGenerationJobCreate(
                    image_id=image_id,
                    priority=THUMBNAIL_JOB_PRIORITY_MEDIUM,
                    status=THUMBNAIL_JOB_STATUS_PENDING,
                    job_type=THUMBNAIL_JOB_TYPE_SINGLE,
                )

                job = self.thumbnail_job_ops.create_job(job_data)
                if job:
                    logger.debug(
                        f"Queued thumbnail job {job.id} for image {image_id} (fallback)"
                    )
                else:
                    logger.warning(
                        f"Failed to queue thumbnail job for image {image_id} (fallback)"
                    )

        except Exception as e:
            logger.error(f"Error queuing background jobs for image {image_id}: {e}")

    def _coordinate_corruption_detection(self, camera_id: int, image_path: str) -> None:
        """Coordinate with corruption detection service."""
        try:
            if self.corruption_service:
                detection_result = self.corruption_service.analyze_image_quality(
                    camera_id=camera_id, image_path=image_path
                )
                logger.debug(f"Corruption detection completed: {detection_result}")
        except Exception as e:
            logger.warning(f"Corruption detection failed for camera {camera_id}: {e}")

    def _get_current_weather_data(self) -> Dict[str, Any]:
        """Get current weather data for image capture."""
        try:
            weather_enabled = self.settings_ops.get_setting("weather_enabled", "false")
            if str(weather_enabled).lower() != "true":
                return {}

            current_weather = self.weather_ops.get_latest_weather()
            if not current_weather or current_weather.get("api_failing", False):
                return {}

            weather_data = {}
            if current_weather.get("current_temp") is not None:
                weather_data["weather_temperature"] = float(
                    current_weather["current_temp"]
                )
            if current_weather.get("current_weather_description"):
                weather_data["weather_conditions"] = str(
                    current_weather["current_weather_description"]
                )
            if current_weather.get("current_weather_icon"):
                weather_data["weather_icon"] = str(
                    current_weather["current_weather_icon"]
                )
            if current_weather.get("weather_date_fetched"):
                weather_data["weather_fetched_at"] = current_weather[
                    "weather_date_fetched"
                ]

            return weather_data

        except Exception as e:
            logger.warning(f"Failed to get weather data: {e}")
            return {}

    def _get_capture_settings(self, force_refresh: bool = False) -> Dict[str, Any]:
        """Get capture settings with default fallbacks."""
        try:
            quality_setting = self.settings_ops.get_setting("image_quality")
            timeout_setting = self.settings_ops.get_setting("rtsp_timeout_seconds")

            quality = DEFAULT_RTSP_QUALITY
            if quality_setting:
                try:
                    quality = int(quality_setting)
                except (ValueError, TypeError):
                    logger.warning(
                        f"Invalid image_quality setting, using default {DEFAULT_RTSP_QUALITY}"
                    )

            timeout = DEFAULT_RTSP_TIMEOUT_SECONDS
            if timeout_setting:
                try:
                    timeout = int(timeout_setting)
                except (ValueError, TypeError):
                    logger.warning(
                        f"Invalid rtsp_timeout_seconds setting, using default {DEFAULT_RTSP_TIMEOUT_SECONDS}"
                    )

            return {"quality": quality, "timeout": timeout}

        except Exception as e:
            logger.warning(f"Failed to get capture settings: {e}")
            return {
                "quality": DEFAULT_RTSP_QUALITY,
                "timeout": DEFAULT_RTSP_TIMEOUT_SECONDS,
            }

    def _get_camera_with_validation(self, camera_id: int) -> Optional[Camera]:
        """Get camera with validation."""
        try:
            camera = self.camera_ops.get_camera_by_id(camera_id)
            if not camera:
                logger.error(f"Camera {camera_id} not found")
            return camera
        except Exception as e:
            logger.error(f"Database error getting camera {camera_id}: {e}")
            return None

    def detect_source_resolution(self, camera_id: int) -> Optional[SourceResolution]:
        """
        Detect and store the source resolution of a camera by capturing a frame.

        This is an RTSP capture operation that belongs in RTSPService.

        Args:
            camera_id: Camera ID

        Returns:
            SourceResolution if successful, None if failed
        """
        try:
            camera = self._get_camera_with_validation(camera_id)
            if not camera:
                return None

            rtsp_url = camera.rtsp_url
            if not rtsp_url:
                logger.error(f"No RTSP URL for camera {camera_id}")
                return None

            # Capture a frame to detect resolution
            logger.debug(f"Detecting source resolution for camera {camera_id}")
            settings = self._get_capture_settings()
            frame = rtsp_utils.capture_with_retry(
                rtsp_url, max_retries=2, timeout_seconds=settings["timeout"]
            )

            if frame is None:
                logger.warning(
                    f"Failed to capture frame for resolution detection: camera {camera_id}"
                )
                return None

            # Get frame resolution
            width, height = rtsp_utils.get_frame_resolution(frame)
            if width == 0 or height == 0:
                logger.error(f"Invalid resolution detected: {width}x{height}")
                return None

            # Create resolution model
            now = time_utils.get_timezone_aware_timestamp_sync(self.settings_ops)
            resolution = SourceResolution(width=width, height=height, detected_at=now)

            logger.info(
                f"Detected source resolution for camera {camera_id}: {width}x{height}"
            )
            return resolution

        except Exception as e:
            logger.error(
                f"Error detecting source resolution for camera {camera_id}: {e}"
            )
            return None

    def test_crop_settings(
        self, camera_id: int, settings: CropRotationSettings
    ) -> Optional[tuple[int, int]]:
        """
        Test crop/rotation settings by capturing and processing a frame.

        This is an RTSP capture operation that belongs in RTSPService.

        Args:
            camera_id: Camera ID
            settings: Settings to test

        Returns:
            Tuple of (processed_width, processed_height) if successful, None if failed
        """
        try:
            camera = self._get_camera_with_validation(camera_id)
            if not camera:
                return None

            rtsp_url = camera.rtsp_url
            if not rtsp_url:
                logger.error(f"No RTSP URL for camera {camera_id}")
                return None

            # Capture a test frame
            logger.debug(f"Testing crop settings for camera {camera_id}")
            capture_settings = self._get_capture_settings()
            frame = rtsp_utils.capture_with_retry(
                rtsp_url, max_retries=2, timeout_seconds=capture_settings["timeout"]
            )

            if frame is None:
                logger.warning(f"Failed to capture test frame for camera {camera_id}")
                return None

            # Apply processing pipeline
            settings_dict = settings.model_dump()
            processed_frame = rtsp_utils.apply_processing_pipeline(frame, settings_dict)

            # Get processed resolution
            width, height = rtsp_utils.get_frame_resolution(processed_frame)

            logger.info(
                f"Test successful for camera {camera_id}: processed to {width}x{height}"
            )
            return width, height

        except Exception as e:
            logger.error(f"Error testing crop settings for camera {camera_id}: {e}")
            return None


class AsyncRTSPService:
    """
    Async wrapper for RTSPService.

    Provides async interface while maintaining sync RTSP operations for reliability.
    Used by async services like CameraService.
    """

    def __init__(self, sync_rtsp_service: RTSPService):
        """Initialize with sync RTSP service."""
        self.sync_rtsp_service = sync_rtsp_service

    async def test_connection(
        self, camera_id: int, rtsp_url: str
    ) -> CameraConnectivityTestResult:
        """Async wrapper for RTSP connection testing."""
        try:
            result = await asyncio.get_event_loop().run_in_executor(
                None,
                self.sync_rtsp_service.test_connection,
                camera_id,
                rtsp_url,
            )
            return result
        except Exception as e:
            logger.error(f"Async RTSP connection test failed for {rtsp_url}: {e}")
            from ..utils.time_utils import get_timezone_aware_timestamp_sync

            return CameraConnectivityTestResult(
                success=False,
                camera_id=camera_id,
                rtsp_url=rtsp_url,
                response_time_ms=None,
                connection_status="async_error",
                error=str(e),
                test_timestamp=get_timezone_aware_timestamp_sync(
                    self.sync_rtsp_service.settings_ops
                ),
            )

    async def capture_preview(self, camera_id: int) -> RTSPCaptureResult:
        """Async wrapper for preview capture."""
        try:
            result = await asyncio.get_event_loop().run_in_executor(
                None,
                self.sync_rtsp_service.capture_preview,
                camera_id,
            )
            return result
        except Exception as e:
            logger.error(f"Async preview capture failed for camera {camera_id}: {e}")
            return RTSPCaptureResult(success=False, error=str(e))

    async def detect_source_resolution(
        self, camera_id: int
    ) -> Optional[SourceResolution]:
        """Async wrapper for source resolution detection."""
        try:
            result = await asyncio.get_event_loop().run_in_executor(
                None,
                self.sync_rtsp_service.detect_source_resolution,
                camera_id,
            )
            return result
        except Exception as e:
            logger.error(
                f"Async source resolution detection failed for camera {camera_id}: {e}"
            )
            return None

    async def test_crop_settings(
        self, camera_id: int, settings: CropRotationSettings
    ) -> Optional[tuple[int, int]]:
        """Async wrapper for crop settings testing."""
        try:
            result = await asyncio.get_event_loop().run_in_executor(
                None,
                self.sync_rtsp_service.test_crop_settings,
                camera_id,
                settings,
            )
            return result
        except Exception as e:
            logger.error(f"Async crop settings test failed for camera {camera_id}: {e}")
            return None
