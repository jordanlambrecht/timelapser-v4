"""
Video Generation Service for Timelapser V4

This service handles the creation of timelapse videos from image sequences,
with support for overlays, multiple quality settings, and database integration.
Adapted from the VideoGenerator class to use service pattern.
"""

import os
import subprocess
import logging
import re
import shutil
import sys
import tempfile
from pathlib import Path
from typing import Tuple, Optional, Union, List, Dict, Any
import glob
from datetime import datetime, date

from ..database import SyncDatabase
from utils.time_utils import (
    parse_iso_timestamp_safe,
    extract_date_from_filename,
)
from utils.timezone_utils import (
    get_timezone_aware_timestamp_sync,
    format_filename_timestamp,
    utc_now,
)

logger = logging.getLogger(__name__)


class VideoGenerationService:
    """
    Service for generating timelapse videos from image sequences.

    This service handles:
    - MP4 video generation from image sequences
    - Dynamic day overlays using FFmpeg and ASS subtitles
    - Multiple quality settings (low, medium, high)
    - Configurable framerates and output formats
    - Database integration for timelapse tracking
    """

    def __init__(self, db: Optional[SyncDatabase] = None):
        """
        Initialize the video generation service.

        Args:
            db: Optional database instance for timelapse data access
        """
        self.default_framerate = 30
        self.default_quality = "medium"
        self.supported_formats = [".jpg", ".jpeg", ".png"]
        self.db = db

        # Day overlay default settings
        self.default_overlay_settings = {
            "enabled": True,
            "position": "bottom-right",
            "font_size": 48,
            "font_color": "white",
            "background_color": "black@0.5",
            "padding": 20,
            "format": "Day {day}",
        }

    def get_overlay_position(
        self, position: str, _font_size: int, padding: int
    ) -> Tuple[str, str]:
        """Convert position name to FFmpeg x,y coordinates."""
        positions = {
            "top-left": (str(padding), str(padding)),
            "top-right": (f"w-text_w-{padding}", str(padding)),
            "bottom-left": (str(padding), f"h-text_h-{padding}"),
            "bottom-right": (f"w-text_w-{padding}", f"h-text_h-{padding}"),
            "center": ("(w-text_w)/2", "(h-text_h)/2"),
        }
        return positions.get(position, positions["bottom-right"])

    def create_day_overlay_filter(
        self, images: list, overlay_settings: Optional[dict] = None
    ) -> Optional[str]:
        """Create FFmpeg drawtext filter for day overlays."""
        if not overlay_settings:
            overlay_settings = self.default_overlay_settings.copy()

        if not overlay_settings.get("enabled", True):
            return None

        # Get position coordinates
        x, y = self.get_overlay_position(
            overlay_settings.get("position", "bottom-right"),
            overlay_settings.get("font_size", 48),
            overlay_settings.get("padding", 20),
        )

        # Build drawtext filter
        font_size = overlay_settings.get("font_size", 48)
        font_color = overlay_settings.get("font_color", "white")
        bg_color = overlay_settings.get("background_color", "black@0.5")
        text_format = overlay_settings.get("format", "Day {day}")

        # Create dynamic text based on frame number
        if len(images) > 0:
            min_day = min(img.get("day_number", 1) for img in images)
            max_day = max(img.get("day_number", 1) for img in images)

            if min_day == max_day:
                display_text = text_format.format(
                    day=min_day, day_of_total=f"{min_day}"
                )
            else:
                display_text = f"Day {min_day}-{max_day}"
        else:
            display_text = "Day 1"

        # Build the drawtext filter
        filter_parts = [
            f"drawtext=text='{display_text}'",
            f"fontsize={font_size}",
            f"fontcolor={font_color}",
            f"x={x}",
            f"y={y}",
        ]

        # Add background box if specified
        if bg_color and bg_color != "none":
            filter_parts.extend(["box=1", f"boxcolor={bg_color}", "boxborderw=5"])

        return ":".join(filter_parts)

    def create_dynamic_day_overlay(
        self, images: list, overlay_settings: Optional[dict] = None
    ) -> Tuple[Optional[str], Optional[str]]:
        """Create dynamic day overlay that changes per frame using ASS subtitles."""
        if not overlay_settings:
            overlay_settings = self.default_overlay_settings.copy()

        if not overlay_settings.get("enabled", True) or not images:
            return None, None

        try:
            with tempfile.NamedTemporaryFile(
                mode="w", suffix=".ass", delete=False
            ) as temp_file:
                temp_file.write(
                    """[Script Info]
Title: Day Overlay
ScriptType: v4.00+

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,{font_size},&H00FFFFFF,&H000000FF,&H00000000,&H80000000,1,0,0,0,100,100,0,0,1,2,0,{alignment},20,20,20,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
""".format(
                        font_size=overlay_settings.get("font_size", 48),
                        alignment=self._get_ass_alignment(
                            overlay_settings.get("position", "bottom-right")
                        ),
                    )
                )

                framerate = 30
                frame_duration = 1.0 / framerate

                for i, image in enumerate(images):
                    start_time = i * frame_duration
                    end_time = (i + 1) * frame_duration
                    day_number = image.get("day_number", 1)

                    start_str = self._seconds_to_ass_time(start_time)
                    end_str = self._seconds_to_ass_time(end_time)

                    text_format = overlay_settings.get("format", "Day {day}")
                    display_text = text_format.format(day=day_number)

                    temp_file.write(
                        f"Dialogue: 0,{start_str},{end_str},Default,,0,0,0,,{display_text}\n"
                    )

                temp_file_name = temp_file.name

            subtitle_filter = f"subtitles={temp_file_name}"
            return temp_file_name, subtitle_filter

        except Exception as e:
            logger.error("Failed to create dynamic overlay: %s", e)
            return None, None

    def _get_ass_alignment(self, position: str) -> int:
        """Convert position name to ASS subtitle alignment number."""
        alignments = {
            "bottom-left": 1,
            "bottom-center": 2,
            "bottom-right": 3,
            "center-left": 4,
            "center": 5,
            "center-right": 6,
            "top-left": 7,
            "top-center": 8,
            "top-right": 9,
        }
        return alignments.get(position, 3)

    def _seconds_to_ass_time(self, seconds: float) -> str:
        """Convert seconds to ASS time format (H:MM:SS.cc)."""
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = seconds % 60
        return f"{hours}:{minutes:02d}:{secs:05.2f}"

    def get_quality_settings(self, quality: str) -> dict:
        """Get FFmpeg quality settings based on quality level."""
        settings = {
            "low": {"crf": 28, "preset": "fast", "scale": "1280:720"},
            "medium": {"crf": 23, "preset": "medium", "scale": "1920:1080"},
            "high": {"crf": 18, "preset": "slow", "scale": None},
        }
        return settings.get(quality, settings["medium"])

    def find_image_files(self, directory: Path) -> list:
        """Find all image files in directory and subdirectories, sorted by filename."""
        image_files = []

        # Check if this is a camera directory with date subdirectories
        has_date_subdirs = any(
            d.is_dir() and re.match(r"\d{4}-\d{2}-\d{2}", d.name)
            for d in directory.iterdir()
            if d.is_dir()
        )

        if directory.name.startswith("camera-") or has_date_subdirs:
            for date_dir in directory.iterdir():
                if date_dir.is_dir() and re.match(r"\d{4}-\d{2}-\d{2}", date_dir.name):
                    for ext in self.supported_formats:
                        pattern = str(date_dir / f"*{ext}")
                        files = glob.glob(pattern)
                        image_files.extend(files)
        else:
            for ext in self.supported_formats:
                pattern = str(directory / f"*{ext}")
                files = glob.glob(pattern)
                image_files.extend(files)

        image_files.sort()
        logger.info("Found %d image files in %s", len(image_files), directory)
        return image_files

    def _prepare_video_filters(
        self,
        quality_settings: dict,
        overlay_settings: Optional[dict],
        day_overlay_data: Optional[list],
    ) -> Tuple[List[str], Optional[str]]:
        """Prepare video filters including scaling and overlays."""
        filters = []
        subtitle_file = None

        # Add scaling if specified
        if quality_settings["scale"]:
            filters.append(f"scale={quality_settings['scale']}")

        # Add day overlay if enabled
        try:
            if (
                overlay_settings
                and overlay_settings.get("enabled", True)
                and day_overlay_data
            ):
                logger.info("Adding day overlay to video")

                subtitle_file, subtitle_filter = self.create_dynamic_day_overlay(
                    day_overlay_data, overlay_settings
                )

                if subtitle_filter:
                    filters.append(subtitle_filter)
                    logger.info("Added overlay filter: %s", subtitle_filter)
                else:
                    static_overlay = self.create_day_overlay_filter(
                        day_overlay_data, overlay_settings
                    )
                    if static_overlay:
                        filters.append(static_overlay)
                        logger.info("Added static overlay: %s", static_overlay)

            elif overlay_settings and overlay_settings.get("enabled", True):
                logger.info("Adding default day overlay")
                default_overlay = self.create_day_overlay_filter([], overlay_settings)
                if default_overlay:
                    filters.append(default_overlay)

        except Exception as e:
            logger.warning("Failed to add overlay, continuing without: %s", e)

        return filters, subtitle_file

    def _build_ffmpeg_command(
        self,
        images_dir: Path,
        framerate: int,
        quality_settings: dict,
        filters: List[str],
        output_path: Path,
    ) -> List[str]:
        """Build the FFmpeg command with all parameters."""
        cmd = [
            "ffmpeg",
            "-y",
            "-framerate",
            str(framerate),
            "-pattern_type",
            "glob",
            "-i",
            str(images_dir / "*.jpg"),
            "-c:v",
            "libx264",
            "-pix_fmt",
            "yuv420p",
            "-crf",
            str(quality_settings["crf"]),
            "-preset",
            quality_settings["preset"],
        ]

        if filters:
            cmd.extend(["-vf", ",".join(filters)])
            logger.info("Applied video filters: %s", filters)

        cmd.append(str(output_path))
        return cmd

    def _execute_ffmpeg_command(
        self, cmd: List[str], images_dir: Path, output_path: Path
    ) -> Tuple[bool, str]:
        """Execute FFmpeg command and return success status and message."""
        cmd_str = " ".join(cmd).replace(str(images_dir.parent), "...")
        logger.info("FFmpeg command: %s", cmd_str)

        start_time = utc_now()
        result = subprocess.run(
            cmd, capture_output=True, text=True, timeout=300, check=False
        )

        duration = (utc_now() - start_time).total_seconds()

        if result.returncode != 0:
            error_msg = f"FFmpeg failed: {result.stderr}"
            logger.error(error_msg)
            return False, error_msg

        if not output_path.exists():
            return False, "Output video file was not created"

        file_size = output_path.stat().st_size
        file_size_mb = file_size / (1024 * 1024)

        success_msg = (
            f"Video generated successfully in {duration:.1f}s. "
            f"File size: {file_size_mb:.1f}MB"
        )
        logger.info(success_msg)
        return True, success_msg

    def generate_video(
        self,
        images_directory: Union[str, Path],
        output_path: Union[str, Path],
        framerate: Optional[int] = None,
        quality: Optional[str] = None,
        overlay_settings: Optional[dict] = None,
        day_overlay_data: Optional[list] = None,
    ) -> Tuple[bool, str]:
        """Generate MP4 video from images in directory."""
        subtitle_file = None

        try:
            images_dir = Path(images_directory)
            if not images_dir.exists():
                return False, f"Images directory does not exist: {images_directory}"

            image_files = self.find_image_files(images_dir)
            if len(image_files) < 2:
                return (
                    False,
                    f"Need at least 2 images to create video, found {len(image_files)}",
                )

            framerate = framerate or self.default_framerate
            quality = quality or self.default_quality
            quality_settings = self.get_quality_settings(quality)

            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)

            logger.info("Generating video from %d images", len(image_files))
            logger.info("Output: %s", output_path)
            logger.info("Settings: %dfps, quality=%s", framerate, quality)

            filters, subtitle_file = self._prepare_video_filters(
                quality_settings, overlay_settings, day_overlay_data
            )

            cmd = self._build_ffmpeg_command(
                images_dir, framerate, quality_settings, filters, output_path
            )

            success, message = self._execute_ffmpeg_command(
                cmd, images_dir, output_path
            )
            return success, message

        except subprocess.TimeoutExpired:
            return False, "Video generation timed out (5 minutes)"
        except Exception as e:
            error_msg = f"Video generation failed: {str(e)}"
            logger.error(error_msg)
            return False, error_msg
        finally:
            if subtitle_file:
                try:
                    os.unlink(subtitle_file)
                except OSError:
                    pass

    def test_ffmpeg_available(self) -> Tuple[bool, str]:
        """Test if FFmpeg is available on the system."""
        try:
            result = subprocess.run(
                ["ffmpeg", "-version"],
                capture_output=True,
                text=True,
                timeout=10,
                check=False,
            )

            if result.returncode == 0:
                version_line = result.stdout.split("\n")[0]
                return True, f"FFmpeg available: {version_line}"

            return False, "FFmpeg command failed"

        except FileNotFoundError:
            return False, "FFmpeg not found. Please install FFmpeg."
        except Exception as e:
            return False, f"Error testing FFmpeg: {str(e)}"

    def _get_timelapse_images_and_stats(
        self, timelapse_id: int, day_start: Optional[int], day_end: Optional[int]
    ) -> Tuple[bool, str, List, Optional[dict]]:
        """Get timelapse images and day statistics."""
        if not self.db:
            return False, "Database connection required", [], None

        try:
            images = self.db.get_timelapse_images(timelapse_id, day_start, day_end)

            if len(images) < 2:
                return (
                    False,
                    f"Need at least 2 images for video, found {len(images)} for timelapse {timelapse_id}",
                    [],
                    None,
                )

            day_stats = self.db.get_timelapse_day_range(timelapse_id)
            return True, "", images, day_stats
        except Exception as e:
            logger.error(f"Error getting timelapse images: {e}")
            return False, str(e), [], None

    def _prepare_video_metadata(
        self,
        images: List,
        video_name: Optional[str],
        day_start: Optional[int],
        day_end: Optional[int],
        overlay_settings: Optional[dict],
    ) -> Tuple[str, int, str]:
        """Prepare video name and metadata."""
        if not images:
            raise ValueError("No images provided for metadata preparation")

        camera_id = images[0]["camera_id"]

        if self.db:
            cameras = self.db.get_active_cameras()
            camera = next((c for c in cameras if c["id"] == camera_id), None)
            camera_name = camera["name"] if camera else f"Camera-{camera_id}"
        else:
            camera_name = f"Camera-{camera_id}"

        max_day = 0
        if self.db:
            day_stats = self.db.get_timelapse_day_range(
                images[0].get("timelapse_id", 0)
            )
            max_day = day_stats["max_day"]
        else:
            max_day = max((img.get("day_number", 0) for img in images), default=0)

        if not video_name:
            if self.db:
                timestamp_iso = get_timezone_aware_timestamp_sync(self.db)
                timestamp_dt = parse_iso_timestamp_safe(timestamp_iso)
                timestamp = format_filename_timestamp(timestamp_dt)
            else:
                fallback_time = utc_now()
                timestamp = format_filename_timestamp(fallback_time)

            day_range = (
                f"_days{day_start}-{day_end}"
                if day_start or day_end
                else f"_day1-{max_day}"
            )
            overlay_suffix = (
                "_overlay"
                if overlay_settings and overlay_settings.get("enabled")
                else ""
            )
            video_name = (
                f"{camera_name}_timelapse{day_range}{overlay_suffix}_{timestamp}"
            )

        return video_name, camera_id, camera_name

    def _create_and_setup_video_record(
        self,
        camera_id: int,
        video_name: str,
        timelapse_id: int,
        framerate: int,
        quality: str,
        day_start: Optional[int],
        day_end: Optional[int],
        output_directory: str,
        overlay_settings: Optional[dict],
    ) -> Optional[int]:
        """Create video record in database and return video_id."""
        if not self.db:
            logger.warning(
                "Database connection not available, skipping video record creation"
            )
            return None

        settings = {
            "framerate": framerate,
            "quality": quality,
            "timelapse_id": timelapse_id,
            "day_start": day_start,
            "day_end": day_end,
            "output_directory": str(output_directory),
            "overlay_settings": overlay_settings,
        }

        video_id = self.db.create_video_record(
            camera_id=camera_id, name=video_name, settings=settings
        )

        if video_id:
            logger.info(
                "Created video record %d for timelapse %d", video_id, timelapse_id
            )

        return video_id

    def _prepare_images_for_processing(
        self, images: List, temp_path: Path
    ) -> Tuple[bool, str, int]:
        """Copy images to temporary directory with sequential naming."""
        for i, image in enumerate(images):
            src_path = Path(image["file_path"])
            if not src_path.exists():
                logger.warning("Image file not found: %s", src_path)
                continue

            ext = src_path.suffix
            dst_path = temp_path / f"frame_{i+1:06d}{ext}"
            shutil.copy2(src_path, dst_path)

        copied_files = list(temp_path.glob("frame_*"))
        if len(copied_files) < 2:
            return (False, f"Only {len(copied_files)} valid image files found", 0)

        logger.info("Copied %d images to temporary directory", len(copied_files))
        return True, "", len(copied_files)

    def _update_video_record_with_results(
        self,
        video_id: int,
        success: bool,
        message: str,
        images: List,
        copied_files_count: int,
        framerate: int,
        output_path: Path,
    ) -> None:
        """Update video record with processing results."""
        if not self.db:
            logger.warning(
                "Database connection not available, skipping video record update"
            )
            return

        if success:
            file_size = output_path.stat().st_size if output_path.exists() else 0
            duration_seconds = copied_files_count / framerate

            start_date = datetime.fromisoformat(str(images[0]["captured_at"])).date()
            end_date = datetime.fromisoformat(str(images[-1]["captured_at"])).date()

            self.db.update_video_record(
                video_id,
                status="completed",
                file_path=str(output_path),
                file_size=file_size,
                duration_seconds=duration_seconds,
                image_count=copied_files_count,
                images_start_date=start_date,
                images_end_date=end_date,
            )

            logger.info("Video %d completed successfully", video_id)
        else:
            self.db.update_video_record(video_id, status="failed")
            logger.error("Video %d generation failed: %s", video_id, message)

    def generate_video_from_timelapse_with_overlays(
        self,
        timelapse_id: int,
        output_directory: Union[str, Path],
        video_name: Optional[str] = None,
        framerate: Optional[int] = None,
        quality: Optional[str] = None,
        day_start: Optional[int] = None,
        day_end: Optional[int] = None,
        overlay_settings: Optional[dict] = None,
    ) -> Dict[str, Any]:
        """
        Generate video from a specific timelapse with overlay support.

        Returns:
            Dictionary with generation results and metadata, compatible with VideoAutomationService expectations
        """
        video_id = None

        try:
            if not self.db:
                return {
                    "success": False,
                    "error": "Database connection required for timelapse video generation",
                    "video_id": None,
                }

            framerate = framerate or self.default_framerate
            quality = quality or self.default_quality

            success, message, images, day_stats = self._get_timelapse_images_and_stats(
                timelapse_id, day_start, day_end
            )
            if not success:
                return {"success": False, "error": message, "video_id": None}

            video_name, camera_id, camera_name = self._prepare_video_metadata(
                images, video_name, day_start, day_end, overlay_settings
            )

            output_dir = Path(output_directory)
            output_dir.mkdir(parents=True, exist_ok=True)
            output_path = output_dir / f"{video_name}.mp4"

            video_id = self._create_and_setup_video_record(
                camera_id,
                video_name,
                timelapse_id,
                framerate,
                quality,
                day_start,
                day_end,
                str(output_directory),
                overlay_settings,
            )

            if not video_id:
                return {
                    "success": False,
                    "error": "Failed to create video record in database",
                    "video_id": None,
                }

            max_day = day_stats["max_day"] if day_stats else "unknown"
            logger.info(
                f"Processing {len(images)} images from days {day_start or 1} to {day_end or max_day}"
            )

            if overlay_settings and overlay_settings.get("enabled"):
                logger.info("Overlay enabled: %s", overlay_settings)

            with tempfile.TemporaryDirectory() as temp_dir:
                temp_path = Path(temp_dir)

                success, error_msg, copied_files_count = (
                    self._prepare_images_for_processing(images, temp_path)
                )
                if not success:
                    return {"success": False, "error": error_msg, "video_id": video_id}

                success, message = self.generate_video(
                    images_directory=str(temp_path),
                    output_path=str(output_path),
                    framerate=framerate,
                    quality=quality,
                    overlay_settings=overlay_settings,
                    day_overlay_data=images,
                )

                self._update_video_record_with_results(
                    video_id,
                    success,
                    message,
                    images,
                    copied_files_count,
                    framerate,
                    output_path,
                )

                if success:
                    success_msg = f"Timelapse video with overlays generated: {video_name}.mp4 ({copied_files_count} images, {copied_files_count/framerate:.1f}s)"
                    return {
                        "success": True,
                        "message": success_msg,
                        "video_id": video_id,
                        "video_path": str(output_path),
                        "duration": copied_files_count / framerate,
                        "image_count": copied_files_count,
                    }
                else:
                    return {
                        "success": False,
                        "error": f"Video generation failed: {message}",
                        "video_id": video_id,
                    }

        except Exception as e:
            error_msg = f"Timelapse video generation with overlays failed: {str(e)}"
            logger.error(error_msg)

            if video_id and self.db:
                try:
                    self.db.update_video_record(video_id, status="failed")
                except Exception:
                    pass

            return {
                "success": False,
                "error": error_msg,
                "video_id": video_id,
            }
