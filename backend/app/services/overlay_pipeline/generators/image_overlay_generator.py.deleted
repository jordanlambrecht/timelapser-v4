# backend/app/services/overlay_pipeline/generators/image_overlay_generator.py
"""
Image Overlay Generator - Handles image-based overlay generation including watermarks.
"""

from typing import Dict, Any, Optional, Tuple
from PIL import Image, ImageEnhance
from pathlib import Path
from loguru import logger

from ..utils.constants import (
    OVERLAY_IMAGE_EXTENSIONS,
    MAX_OVERLAY_IMAGE_SIZE_MB,
    MAX_OVERLAY_RESOLUTION,
    DEFAULT_OVERLAY_X_MARGIN,
    DEFAULT_OVERLAY_Y_MARGIN,
)


class ImageOverlayGenerator:
    """
    Generator for image-based overlays including watermarks,
    logos, and other image overlays.
    """

    def __init__(self):
        """Initialize image overlay generator."""
        pass

    def generate_image_overlay(
        self,
        image: Image.Image,
        overlay_image_path: str,
        position: str,
        scale: float = 1.0,
        opacity: int = 100,
        x_margin: int = DEFAULT_OVERLAY_X_MARGIN,
        y_margin: int = DEFAULT_OVERLAY_Y_MARGIN,
    ) -> Image.Image:
        """
        Generate image overlay on base image.

        Args:
            image: PIL Image to add overlay to
            overlay_image_path: Path to overlay image file
            position: Position on 9-grid system
            scale: Scale factor for overlay image (1.0 = original size)
            opacity: Overlay opacity (0-100)
            x_margin: Horizontal margin from edge
            y_margin: Vertical margin from edge

        Returns:
            Image with overlay applied
        """
        try:
            # Validate overlay image path
            overlay_path = Path(overlay_image_path)
            if not overlay_path.exists():
                logger.error(f"Overlay image not found: {overlay_image_path}")
                return image

            if overlay_path.suffix.lower() not in OVERLAY_IMAGE_EXTENSIONS:
                logger.error(f"Unsupported overlay image format: {overlay_path.suffix}")
                return image

            # Check file size
            file_size_mb = overlay_path.stat().st_size / (1024 * 1024)
            if file_size_mb > MAX_OVERLAY_IMAGE_SIZE_MB:
                logger.error(f"Overlay image too large: {file_size_mb:.1f}MB")
                return image

            # Load overlay image
            overlay_img = Image.open(overlay_path)
            
            # Convert to RGBA if needed
            if overlay_img.mode != 'RGBA':
                overlay_img = overlay_img.convert('RGBA')

            # Validate resolution
            if overlay_img.size[0] > MAX_OVERLAY_RESOLUTION[0] or overlay_img.size[1] > MAX_OVERLAY_RESOLUTION[1]:
                logger.error(f"Overlay image resolution too high: {overlay_img.size}")
                return image

            # Scale overlay if needed
            if scale != 1.0:
                new_size = (
                    int(overlay_img.size[0] * scale),
                    int(overlay_img.size[1] * scale)
                )
                overlay_img = overlay_img.resize(new_size, Image.Resampling.LANCZOS)

            # Adjust opacity
            if opacity < 100:
                overlay_img = self._adjust_opacity(overlay_img, opacity)

            # Calculate position
            x, y = self._calculate_image_position(
                image, overlay_img, position, x_margin, y_margin
            )

            # Create a copy to avoid modifying original
            result_image = image.copy()
            
            # Convert to RGBA for compositing
            if result_image.mode != 'RGBA':
                result_image = result_image.convert('RGBA')

            # Composite the overlay
            result_image.paste(overlay_img, (x, y), overlay_img)

            # Convert back to original mode if needed
            if image.mode != 'RGBA':
                result_image = result_image.convert(image.mode)

            return result_image

        except Exception as e:
            logger.error(f"Failed to generate image overlay: {e}")
            return image

    def generate_watermark_overlay(
        self,
        image: Image.Image,
        watermark_path: str,
        position: str = "bottom_right",
        scale: float = 0.2,
        opacity: int = 50,
        **kwargs
    ) -> Image.Image:
        """
        Generate watermark overlay (convenience method).

        Args:
            image: PIL Image to add watermark to
            watermark_path: Path to watermark image
            position: Position on image (default: bottom_right)
            scale: Scale factor (default: 0.2 for 20% of original size)
            opacity: Watermark opacity (default: 50 for subtle watermark)
            **kwargs: Additional parameters

        Returns:
            Image with watermark applied
        """
        return self.generate_image_overlay(
            image=image,
            overlay_image_path=watermark_path,
            position=position,
            scale=scale,
            opacity=opacity,
            **kwargs
        )

    def _calculate_image_position(
        self,
        base_image: Image.Image,
        overlay_image: Image.Image,
        position: str,
        x_margin: int,
        y_margin: int,
    ) -> Tuple[int, int]:
        """Calculate overlay image position based on position string and margins."""
        from ..utils.constants import POSITION_MAPPING
        
        base_width, base_height = base_image.size
        overlay_width, overlay_height = overlay_image.size
        
        # Convert position to camelCase if needed
        if position in POSITION_MAPPING:
            camel_position = POSITION_MAPPING[position]
        else:
            # Already in camelCase or handle as-is
            camel_position = position
        
        # Calculate position based on 9-grid system
        if camel_position.startswith("top"):
            y = y_margin
        elif camel_position == "centerLeft" or camel_position == "centerRight":
            y = (base_height - overlay_height) // 2
        elif camel_position == "center":
            y = (base_height - overlay_height) // 2
        else:  # bottom
            y = base_height - overlay_height - y_margin
            
        if camel_position.endswith("Left"):
            x = x_margin
        elif camel_position.endswith("Center") or camel_position == "center":
            x = (base_width - overlay_width) // 2
        else:  # Right
            x = base_width - overlay_width - x_margin
            
        return x, y

    def _adjust_opacity(self, image: Image.Image, opacity: int) -> Image.Image:
        """Adjust image opacity."""
        if image.mode != 'RGBA':
            image = image.convert('RGBA')
        
        # Create an alpha mask
        alpha = image.split()[-1]
        alpha = ImageEnhance.Brightness(alpha).enhance(opacity / 100)
        
        # Apply the alpha mask
        image.putalpha(alpha)
        return image